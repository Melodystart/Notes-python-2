# 中級約維安學習筆記 - python

https://datainpoint.substack.com/s/jovyans

## 第十四週 | Python 的資料結構。
```
串列 list
tuple
字典 dict
集合 set
```
- 在 Python 中物件（Objects）是類別（Classes）的實例（Instances）
-  Python 中使用函數有兩種機制，一是對資料型別或資料結構應用函數；二是呼叫綁定於資料型別或資料結構的方法，這時要注意，我們不再稱呼「函數」，而是改稱「方法」。
```
primes_list = [11, 7, 5, 3, 2]
sorted(primes_list) # Apply sorted function to primes_list 函數
primes_list.sort()  # Call sort method of primes_list 方法
```
- sorted(a_list_to_be_sorted) 是以回傳值輸出排序後的串列，因此如果沒有將回傳值更新原本命名的串列，排序的更動並不會被保留。
```
primes_list = [11, 7, 5, 3, 2]
sorted(primes_list) # Apply sorted function to primes_list
print(primes_list)  # primes_list is not sorted
primes_list = sorted(primes_list)  # Update primes_list with function output
print(primes_list)  # primes_list is now sorted
## [11, 7, 5, 3, 2]
## [2, 3, 5, 7, 11]
```
- 而 a_list_to_be_sorted.sort() 則是直接將排序更動了，不需要更新原本命名的串列，也不會伴隨有回傳值。
```
primes_list = [11, 7, 5, 3, 2]
primes_list.sort()  # Call sort method of primes_list
print(primes_list)  # primes_list is sorted
## [2, 3, 5, 7, 11]
```
- 函數或者方法多數情況下會在「以回傳值輸出」或「直接更動物件狀態」中擇一，少數情況下也會有兩者兼具的情況，例如串列方法 pop() 能夠將串列末端的資料拋出為回傳值，並刪除串列末端的資料點。
```
primes_list = [11, 7, 5, 3, 2]
the_last_element = primes_list.pop()
print(primes_list)       # The last element was deleted
print(the_last_element)  # The last element was returned
## [11, 7, 5, 3]
## 2
```
### 串列 list
- 有時候我們也使用 Python 的內建函數 list() 來建立串列，例如常被用來生成數列的內建函數 range() 其輸出是一個可以被迭代的物件（Iterable），屬於 range 類別，如果直接應用不會被印出所有的數字，這時可以用 list() 函數將它轉換為 list 來觀察其中包含的數字。
```
integer_sequence = range(10)
print(integer_sequence)
print(list(integer_sequence))
## range(0, 10)
## [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
1. 索引（Indexing）：選擇串列中的資料我們使用中括號 [] 搭配索引值，值得注意的是索引值從左邊由 0 開始，而非由 1 開始。從右邊則由 -1 開始。
2. 切割（Slicing） ：

(1) 利用 [start:stop:step] 語法對串列指定要切割出來的子集，其中 stop 不會出現在最後選擇出來的結果中，例如我們希望將位於 [0] 、 [1] 、 [2] 的資料另外切割為一個長度為 3 的串列，要使用 [0:3] 而非 [0:2]。

(2) 使用切割的語法時， start 、 stop 與 step 這三個參數都有預設值， start 預設是 0， stop 預設為串列的長度， step 預設為 1，假如沒有指定就採預設值，像是切割出位於 [0] 、 [2] 與 [4] 這三個位置的資料可以簡單使用 [::2] 。

(3) 比較特別的 step 參數如果指定為 -1 可以將串列中的資料順序反轉（Reverse）。
```
print(primes_list[::-1])
## [11, 7, 5, 3, 2]
```
3. 除了索引與切割，常用的串列操作還有新增、刪除與排序資料。

(1) 新增可以使用串列的append() 方法將資料加入到串列末端，這個方法採用直接更動沒有輸出的機制。

(2) 刪除可以使用串列的 pop() 方法將串列末端的資料拋出，這個方法同時採用回傳值與直接更動的機制。
```
primes_list.pop()  # 13 is popped out and returned
print(primes_list) # 13 was deleted
## [2, 3, 5, 7, 11]
```
(3) 排序可以使用串列的 sort() 方法將串列的資料以遞增排序，亦可以指定參數 reverse=True 以遞減排序，這個方法採用直接更動沒有輸出的機制。
```
primes_list = [2, 3, 5, 7, 11]
primes_list.sort(reverse=True)
print(primes_list) # primes_list is now sorted with descending order
primes_list.sort()
print(primes_list) # primes_list is now sorted with ascending order
## [11, 7, 5, 3, 2]
## [2, 3, 5, 7, 11]
```
### tuple
- tuple 與串列最大的差異在於 tuple 是不可變動（Immutable）的資料結構，不具備任何包含新增、刪除與排序資料的操作，這樣的特性讓 tuple 被設計在函數的彈性參數與預設多個回傳值之中。自行定義函數時如果希望參數為不定個數，例如一個能夠進行兩個數字、三個數字甚至 n 個數字相加的函數，彈性參數 *args 在函數作用域中其實就是一個 tuple。
```
def add_n_numbers(*args):
    print(type(args))
    return sum(args)

add_n_numbers(55, 66)
add_n_numbers(55, 66, 77)
## <class 'tuple'>
## 121
## <class 'tuple'>
## 198
```
### 字典 dict
- 新增可以直接宣告 dict_to_be_added["Key"] = Value。
```
primes_dict["6th"] = 13
print(primes_dict)
## {'1st': 2, '2nd': 3, '3rd': 5, '4th': 7, '5th': 11, '6th': 13}
```
- 刪除可以使用字典的 pop(Key, None) 方法將指定的「鍵」與「資料」組合拋出，假如找不到就拋出 None。
```
the_popped_value = primes_dict.pop("6th", None)
print(primes_dict)
## {'1st': 2, '2nd': 3, '3rd': 5, '4th': 7, '5th': 11}
```
- 使用字典的 keys() 、 values() 與 items() 方法，可以分別取出字典中的所有的鍵（Keys）、所有資料（Values）以及「鍵」與「資料」組合（Items）。
```
print(primes_dict.keys())
print(primes_dict.values())
print(primes_dict.items())
## dict_keys(['1st', '2nd', '3rd', '4th', '5th'])
## dict_values([2, 3, 5, 7, 11])
## dict_items([('1st', 2), ('2nd', 3), ('3rd', 5), ('4th', 7), ('5th', 11)])
```
### 集合 set
- 集合 set 是 Python 中用來處理「集合運算」的資料結構，在建立的時候使用大括號 {} 將希望儲存的資訊包括起來，並將希望存放的資料型別與資料結構以逗號分隔。
```
primes_set = {2, 3, 5, 7, 11}
print(type(primes_set))
## <class 'set'>
```
- 這個資料結構用來對應數學中的集合相關定理和操作，所以其中只儲存獨一的資料，若輸入多筆重複資料，則會記錄一筆獨一值，並且是一種「無序」的結構，儲存在其中的資料跟建立時的順序性沒有關聯，可能會在操作後更動順序，但這並無大礙，因為集合並不支援索引，無序這個特性也不會影響集合相關定理和操作。
- 基礎的集合操作有四個：
1. 交集（Intersection）
2. 聯集（Union）
3. 差集（Difference）
4. 對稱差集（Symmetric difference）

上述這四個基礎集合操作都能夠透過呼叫集合的方法實作，其中只有差集沒有交換律（如同減法或者除法一般），另外三者都具有交換律（如同加法或者乘法一般），這些方法都採用以回傳值輸出的機制。
```
primes_set = {2, 3, 5, 7, 11}
odds_set = {1, 3, 5, 7, 9}
print(primes_set.intersection(odds_set))
print(primes_set.union(odds_set))
print(primes_set.difference(odds_set))
print(odds_set.difference(primes_set))
print(primes_set.symmetric_difference(odds_set))
## {3, 5, 7}
## {1, 2, 3, 5, 7, 9, 11}
## {2, 11}
## {1, 9}
## {1, 2, 9, 11}
```
## 第十五週 | Python 的流程控制。
```
Python 實現流程控制有三種方式：條件判斷、迴圈、例外處理。

條件判斷能夠使用 if-elif-else 敘述與布林完成；
迴圈則有兩種選擇，一是使用 while 敘述與布林，二是使用 for 敘述與可走訪物件（Iterables）；
例外處理能夠使用 try-except 敘述與錯誤種類完成。
```
### 條件判斷
- 條件判斷是依指定變數或者運算的布林值為真或假時，來決定是否執行一段位於某區塊內的程式，透過 if-elif-else 敘述可以根據指定條件是否成立。
- 假如條件彼此之間是互斥的，條件判斷怎麼寫大概都沒有問題
```
def get_bmi_desc(bmi):
    if bmi < 18.5:
        bmi_desc = "過輕"
    elif bmi >= 30:
        bmi_desc = "肥胖"
    elif bmi >= 25 and bmi < 30:
        bmi_desc = "過重"
    elif bmi >= 18.5 and bmi < 25:
        bmi_desc = "正常"
    return bmi_desc

print(get_bmi_desc(17))
print(get_bmi_desc(23))
print(get_bmi_desc(29))
print(get_bmi_desc(31))
```
- 但反過來說，假如條件彼此之間是「非互斥」的話，判斷的順序以及 if 敘述、if-elif 與 if-else 敘述就會需要謹慎地選擇。
```
def get_bmi_desc(bmi):
    if bmi >= 30:
        bmi_desc = "肥胖"
    elif bmi >= 25:
        bmi_desc = "過重"
    elif bmi >= 18.5:
        bmi_desc = "正常"
    else:
        bmi_desc = "過輕"
    return bmi_desc

print(get_bmi_desc(17))
print(get_bmi_desc(23))
print(get_bmi_desc(29))
print(get_bmi_desc(31))
```
### 迴圈
- start：迴圈的開始。
- stop：迴圈的結束。
- step：迴圈從起始前往終止的方法。
- 我們可以使用保留字 while 與條件建立一個 while 迴圈區塊，當條件為 True 重複執行依附其縮排下的程式區塊，描述迴圈的 step 常用複合運算符（Compound operators），例如 i += step 就等同於 i = i + step。
```
i = 0 # start
while CONDITION: # stop
    # code block attached to while statement
    i += step
```
- 我們可以使用保留字 for 與可走訪物件（Iterables）建立一個 for 迴圈區塊，依附其縮排下的程式區塊會重複執行，直到可走訪物件中的所有元素都被走訪完畢。
```
for i in ITERABLE: # start/stop/step
    # code block attached to for statement
```
```
ITERABLE 可以內建函數 range() 生成，例如印出前 n 個奇數。
help(range)
def print_first_n_odds(n):
    iterable = range(1, n*2, 2)
    for i in iterable:
        print(i)

print_first_n_odds(5)
```
- 我們可以藉由判斷區塊程式「重複執行的次數是否已知」來決定，已知重複執行次數的情境可以用任意迴圈，未知重複執行次數的情境僅能採用 while 迴圈。這個說法是依據 while 迴圈與 for 迴圈的主要差別，while 在重複執行區塊程式的時候，會在 CONDITION 為 False 的時候終止；而 for 在重複執行區塊程式的時候，會在可迭代物件中的元素用罄時候終止。
- 這表示 while 迴圈根據一個型別為布林變數的物件決定重複執行程式區塊是否終止；for 迴圈則根據一個已知元素數量的可迭代物件決定重複執行程式區塊是否終止。
- 在 Python 中所謂的可走訪物件（Iterables）是任意長度的資料結構（包含串列、Tuples、集合、字典）或者文字，這些可走訪物件都能夠直接放置在 for 迴圈中使用。
```
def print_iterable_elements(x):
    for e in x:
        print(e)

primes_list = [2, 3, 5, 7, 11]
primes_tuple = (2, 3, 5, 7, 11)
primes_set = {2, 3, 5, 7, 11}
primes_str = "2357"
print_iterable_elements(primes_list)
print_iterable_elements(primes_tuple)
print_iterable_elements(primes_set)
print_iterable_elements(primes_str)
```
- 但字典是具有鍵（keys）與資料（values）的資料結構，在走時要特別留意是希望走訪字典的鍵或者字典的值，透過字典的 keys() 、 values() 與 items() 方法分別可以取出鍵、資料或者兩者，其中 items() 方法會將標籤以及資料兩兩合併在一個 Tuple 中。
```
primes_dict = {
    "1st": 2,
    "2nd": 3,
    "3rd": 5,
    "4th": 7,
    "5th": 11
}
# Iterating a dict
for k in primes_dict.keys():
    print(k)
for v in primes_dict.values():
    print(v)
for k, v in primes_dict.items():
    print("{} is the {} prime.".format(v, k))
```
- 將流程控制的兩個技巧條件判斷與迴圈合併使用會讓我們的程式撰寫更有彈性，保留字 break 能夠讓我們在走訪的過程中在條件為 True 的時候終止迴圈，舉例來說當走訪到非整數的時候終止迴圈。
```
primes = [2, 3, "5", 7, 11]
for p in primes:
    if not isinstance(p, int):
        break
    print(p)
```
- 保留字 continue 能夠讓我們在走訪的過程中在條件為 True 的時候略過該元素但是繼續完成迴圈，舉例來說當走訪到非整數的時候略過。
```
primes = [2, 3, "5", 7, 11]
for p in primes:
    if not isinstance(p, int):
        continue
    print(p)
```
### 例外處理
- 我們可以使用保留字 try、except 與錯誤類別建立一個例外處理區塊，依附 try 保留字縮排下的程式區塊一但執行時遭遇到了錯誤，就會跳過該區塊改為執行依附 except 保留字縮排下的程式區塊。
```
try:
    # code block attached to try statement
except:
    # code block attached to except statement
```
- 若在保留字 except 之後加上錯誤類別可以依照產生的錯誤，回傳不同的對應輸出。
```
def divide(a, b):
    try:
        return a / b
    except TypeError:
        return "TypeError occurred."
    except ZeroDivisionError:
        return "ZeroDivisionError occured."

print(divide(55, '0'))
print(divide(55, 0))
print("This message will be printed.")
print("This message will also be printed.")
```
## 第十六週 | Python 的函數。
- 內建函數與詳細介紹可以參考：https://docs.python.org/3/library/functions.html。
### 函數
在 Python 中最常見的函數使用方式是在函數名稱後接上小括號，並在小括號中輸入物件名稱（該物件所儲存的可能是某個資料型別或者資料結構）以及引數（如果函數有任何參數設計）。
```
function_name(OBJECT, ARGUMENTS)
```
### 方法
由於 Python 屬於物件導向（Object-oriented）程式語言，第二種函數定義的形式是綁定於物件之上，這時候使用的方式就變成了在物件名稱後接上附屬符號（.）再接上函數名稱、小括號與引數（如果函數有任何參數設計），在第二種形式中，不只在使用上的語法相異，在稱呼上我們也不再用「函數」，而是改稱物件的「方法」。
```
OBJECT.method_name(ARGUMENTS)
```
- 例如 Python 有一個內建函數 sorted()，串列有一個方法 sort()，兩者都能夠排序一個串列，但是在使用的語法與意義上不同，使用內建函數 sorted() 排序串列是我們習慣且直觀的「對資料結構應用函數」，語法是 sorted(a_list_to_be_sorted)；使用串列方法 sort() 排序是目前較陌生的「使用綁定於資料結構的方法」，語法是 a_list_to_be_sorted.sort()。
```
primes_list = [11, 7, 5, 3, 2]
sorted(primes_list) # Apply sorted function to primes_list primes_list.sort()  # Call sort method of primes_list
```
- 參數與引數的差別：在排序串列的時候，我們可以選擇要「遞增地」排序或者「遞減地」排序，這可以透過傳入的引數（Arguments）調整函數的參數（Parameters），具體來說，函數在定義的階段需要使用的資料型別或資料結構稱為參數，在使用的階段需要指定給參數的資料型別或資料結構就稱為引數。
```
def function_name(parameter_1, parameter_2):
    # body of the function
    # ...
    # ...sequence of statements

function_name(argument_1, argument_2)
```
- 通常參數會給予預設值，例如 sorted() 函數與串列的 sort() 方法都具有 reverse 參數，預設值給定為 True。所以在沒有傳入引數的狀況下，其實就是採用 reverse=False 的參數設定，假使不想採用預設值，就能選擇以名稱（Named）參數來傳入引數。
```
primes_list = [11, 7, 5, 3, 2]
sorted(primes_list)
sorted(primes_list, reverse=True) # Named
primes_list.sort()
primes_list.sort(reverse=True) # Named
```
### 更動結果的機制
- 除了使用「函數」或「方法」的差異，另外值得注意之處在於函數與方法的使用都可能讓應用或所屬的物件造成更動，一種更動方式是以回傳值型態輸出更動後的結果；另一種更動方式是直接更動資料型別與資料結構而沒有輸出。這個差異能夠延續前述內建函數 sorted() 與串列方法 sort() 的例子，sorted(a_list_to_be_sorted) 是以回傳值輸出排序後的串列，因此如果沒有將回傳值更新原本命名的串列，排序的更動並不會被保留。
```
primes_list = [11, 7, 5, 3, 2]
sorted(primes_list) # Apply sorted function to primes_list print(primes_list)  # primes_list is not sorted 
primes_list = sorted(primes_list)  # Update primes_list with function output
print(primes_list)  # primes_list is sorted
```
-而 a_list_to_be_sorted.sort() 則是直接將排序更動了，不需要更新原本命名的串列，也不會伴隨有回傳值。
```
primes_list = [11, 7, 5, 3, 2]
primes_list.sort()  # Call sort method of primes_list print(primes_list)  # primes_list is sorted
```
- 多數情況下函數與方法會在「以回傳值輸出」或「直接更動物件的狀態」擇一，少數情況下會有兩者兼具的情況，例如串列方法 pop() 能夠將串列末端的資料拋出為回傳值，並刪除串列末端的資料點。
```
primes_list = [11, 7, 5, 3, 2]
the_last_element = primes_list.pop()
print(primes_list)       # The last element was deleted print(the_last_element)  # The last element was returned
```
- 這意味著設計為「函數」或者「物件的方法」並不代表恰好對應「以回傳值輸出」或「直接更動物件狀態」，絕大多數的函數確實是以回傳值輸出，但物件的方法則可能有以回傳值輸出的設計、有直接更動物件狀態的設計甚至是用參數來決定要回傳值輸出或直接更動物件狀態。例如資料科學模組 Pandas 所創造的 DataFrame 類別的 drop 方法就是採用 inplace 參數來決定「以回傳值輸出」或「直接更動物件狀態」。
```
import pandas as pd

df = pd.DataFrame()
df["order"] = list(range(1, 6))
df["prime"] = [2, 3, 5, 7, 11]
df.drop(axis=1, labels="prime")
print(df) # Column is not dropped
df.drop(axis=1, labels="prime", inplace=True)
df # Column was dropped
```
### 函數的來源
Python 使用者除了能夠應用內建函數以外，還可以從其他三個管道取得數值計算、文字處理、資料結構或更多其他應用所需的函數：
1. 標準模組。
2. 第三方模組。
3. 自行定義。
僅有內建函數可以供我們直接使用，另外這三個管道的函數都必須在使用之前確定好在欲產生作用的範疇（作用域）中已經被載入或者定義。

載入模組的保留字是 import，使用模組的函數則需要在其名稱之前註明其模組名稱，例如引入標準模組 random，然後使用其中的 randint 函數隨機在 0 與 1 之間挑選整數。
```
import random 

print(type(random))
print(type(random.randint))
random_integer = random.randint(0, 1)
print(random_integer)
```
- 自行定義函數
```
函數名稱：購買珍珠鮮奶茶。
輸入：中杯 35 元；大杯 50 元。
參數：甜度（無糖、微糖、半糖、少糖、全糖）與冰塊（去冰、少冰、全冰）。
函數主體：點餐、貼標籤、加珍珠、加冰塊、倒茶、加鮮奶一直到封口。
輸出：珍珠鮮奶茶。

def function_name(INPUTS, PARAMETERS):
    # body of the function
    # ...
    # ...sequence of statements
    return OUTPUTS
```
